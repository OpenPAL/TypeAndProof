\section{直觉主义命题逻辑}

直觉主义逻辑又称构造性逻辑，产生于第三次数学危机之后。直觉主义者认为，集合论悖论的出现提醒我们必须根据可信性的要求对整个数学作全面的审查。什么样的概念和方法是可信的呢？他们提出的口号是”存在必须被构造“，就是说，所有的数学概念和方法都必须是构造性的，能够按照可操作的固定的方法，在有限步之内定义和实现。


在经典逻辑中，命题的解释是它断言的某种性质的真假意义，即命题的真值；而在直觉主义逻辑中，命题的解释是它断言的某种性质的可构造性。对于公式$A$，$A$的直观含义是``$A$是可构造的''，因此``证明$A$''意味着``构造$A$''。


直觉主义逻辑和经典逻辑的最大区别是不承认排中律，即不承认$A \lor \neg A$是可构造的。直觉主义逻辑认为，公式$A$意味着``$A$是可构造的''，而公式$(\neg A)$意味着`` `$A$不能被构造' 是可构造的''。也就是说，非``$A$是可构造的''并不等价于对$(\neg A)$的构造，非``$A$是可构造的''仅意味着``$A$不能被构造''这个断言本身，但并没有给出对这个断言的构造。

另外，直觉主义不承认实无穷，只承认有限和潜无穷。按照直觉主义逻辑的观点，因为无穷的构造不可能结束，所以不是实际可构造的。


\subsection{语法}

本节采用直觉主义逻辑形式系统中，有三个逻辑连接词$\land$，$\to$和$\top$。$\alpha$表示原子命题，$A, B...$是通过语法规则生成的公式。

$$A, B ::= \alpha \ | \ A \to B \ | \ A \land B \ | \ \top$$




\subsection{BHK语义}

公式在直觉主义逻辑中是有效（valid）的，当前仅当它对于任何Heting代数上的任何赋值总得到1

本节重点关注证明系统，语义部分待补充。。



\subsection{自然演绎系统}

请读者回顾经典命题逻辑的自然演绎系统。 公式$A$的证明或者导出(derivation)建立在一系列假设(assumptions)之上。为了方便叙述，我们在这一节引入新的记号，把公式$A$ 的假设记为 $\Gamma = \{A_1, A_2,...,A_n\}$。

\begin{prooftree}
\AxiomC{$[x_1:A_1,...,x_n:A_n]$}
\noLine
\UnaryInfC{$A$}
\end{prooftree}

以上形式的涵义是：基于假设集$\Gamma$（也就是$A_1, A_2,...$）可以导出$A$。值得注意的是，为求方便我们增加了$x_1, x_2...$等符号，它们表示各个假设的`` 名"，或者`` 记号"。导出过程可能使用假设集中的假设零次或者不止一次，某个假设可能会被``消耗''。

下面是直觉主义逻辑自然演绎系统的规则。每个逻辑连接词由相应的导入/消去规则刻画。

1. \textbf{公理}：从假设$A$出发，可以证明$A$。写在规则右边的$x$表示``名"为$x$的假设被使用了。

\begin{prooftree}
  \AxiomC{$[x:A]$}
  \noLine
  \LeftLabel{$(ax)$}   \RightLabel{$\quad x$}
  \UnaryInfC{$A$}


\end{prooftree}

2. \textbf{$\land$引入}：如果基于$\Gamma$分别可以证明$A$和$B$，则可以证得$A \land B$的。换句话说：$A \land B$的一个证明，是一个$A$ 的证明和一个$B$的证明。

\begin{prooftree}
  \AxiomC{$[\Gamma]$}
  \noLine
  \UnaryInfC{$A$}
    \AxiomC{$[\Gamma]$}
    \noLine
    \UnaryInfC{$B$}
    \LeftLabel{$(\land I)$}
    \BinaryInfC{$A \land B$}

\end{prooftree}


3. \textbf{$\land$消去}：从$A \land B$可以证得$A$和$B$。

\begin{prooftree}
\AxiomC{$[\Gamma]$}
\noLine
\UnaryInfC{$A \land B$}
\LeftLabel{$(\land E)$}
\UnaryInfC{$A$}

\end{prooftree}



\begin{prooftree}
\AxiomC{$[\Gamma]$}
\noLine
\UnaryInfC{$A \land B$}
\LeftLabel{$(\land E)$}
\UnaryInfC{$B$}
\end{prooftree}


4. \textbf{$\top$引入}：不需要任何假设就能得到$\top$。


\begin{prooftree}
\AxiomC{}
\LeftLabel{$(\top I)$}
\UnaryInfC{$\top$}

\end{prooftree}

5. \textbf{$\to$引入}：如果基于假设$[\Gamma, x:A]$可以证明$B$，则基于假设$\Gamma$可以证明$A \to B$。要注意的是，$x :A$ 并从假设中``消耗"了。为表强调我们在规则后写上$x$（$A$的标记）。

\begin{prooftree}
\AxiomC{$[\Gamma, x:A]$}
\noLine
\UnaryInfC{$B$}
\LeftLabel{$(\to I)$}  \RightLabel{$x$}
\UnaryInfC{$A \to B$}

\end{prooftree}


6. \textbf{$\to$消去}：（等价于Hilbert系统的MP规则）


\begin{prooftree}
  \AxiomC{$[\Gamma]$}
  \noLine
  \UnaryInfC{$A \to B$}
    \AxiomC{$[\Gamma]$}
    \noLine
    \UnaryInfC{$A$}
    \LeftLabel{$(\to E)$}
    \BinaryInfC{$B$}

\end{prooftree}





为了更直观地体现与类型论的共同点，我们介绍自然演绎的另一种等价的表达形式。


在这种形式中，演绎规则不是导出一个个公式，而是使用了断言（judgment）的形式。它表示公式$B$是假设集$A_1,...,A_n$的后承。
$$x_1:A,...,x_n:A_n \vdash B$$。这种写法可能会导致证明树有大量``$\Gamma$''而显得冗余，但是实际上更直观。





1. \textbf{公理}

\begin{prooftree}
\AxiomC{}
\LeftLabel{$(ax_x)$}
\UnaryInfC{$\Gamma, x:A \vdash A$}

\end{prooftree}




2. \textbf{$\land$引入}

\begin{prooftree}
    \AxiomC{$\Gamma \vdash A$}
    \AxiomC{$\Gamma \vdash B$}
\LeftLabel{$(\land I)$}
    \BinaryInfC{$B$}
\end{prooftree}

3. \textbf{$\land$消去}

\begin{prooftree}

\AxiomC{$\Gamma \vdash A \land B$}
\LeftLabel{$(\land E_1)$}
\UnaryInfC{$\Gamma \vdash A$}
\end{prooftree}

\begin{prooftree}

\AxiomC{$\Gamma \vdash A \land B$}
\LeftLabel{$(\land E_2)$}
\UnaryInfC{$\Gamma \vdash B$}
\end{prooftree}


4. \textbf{$\top$引入}

\begin{prooftree}
\AxiomC{}
\LeftLabel{$(\top I)$}
\UnaryInfC{$\Gamma \vdash \top$}
\end{prooftree}

5. \textbf{$\to$引入}

\begin{prooftree}
\AxiomC{$\Gamma , x:A \vdash B $}
\LeftLabel{$ (\to I_x)$}
\UnaryInfC{$\Gamma \vdash A \to B$}
\end{prooftree}

6. \textbf{$\to$消去}

\begin{prooftree}
\AxiomC{$\Gamma \vdash A \to B $}
\AxiomC{$\Gamma \vdash A$}
\LeftLabel{$(\to E)$}
\BinaryInfC{$\Gamma \vdash B$}
\end{prooftree}


